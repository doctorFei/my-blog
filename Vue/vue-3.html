<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue 的生命周期 | 雨巷的博客</title>
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/my-blog/assets/img/favicon.ico">
    <link rel="manifest" href="/my-blog/manifest.json">
    <link rel="apple-touch-icon" href="/my-blog/icons/apple-touch-icon-152x152.png">
    <link rel="mask-icon" href="/my-blog/icons/safari-pinned-tab.svg" color="#3eaf7c">
    <meta name="description" content="雨巷的博客">
    <meta name="author" content="雨巷的博客">
    <meta name="keywords" content="雨巷的博客">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    <link rel="preload" href="/my-blog/assets/css/0.styles.48b128da.css" as="style"><link rel="preload" href="/my-blog/assets/js/app.8b8b2b3a.js" as="script"><link rel="preload" href="/my-blog/assets/js/2.9a1f826b.js" as="script"><link rel="preload" href="/my-blog/assets/js/10.a7bc797a.js" as="script"><link rel="preload" href="/my-blog/assets/js/3.824b3276.js" as="script"><link rel="prefetch" href="/my-blog/assets/js/11.2310ec6f.js"><link rel="prefetch" href="/my-blog/assets/js/12.74be65ee.js"><link rel="prefetch" href="/my-blog/assets/js/13.0c0d7a46.js"><link rel="prefetch" href="/my-blog/assets/js/14.42cd1996.js"><link rel="prefetch" href="/my-blog/assets/js/15.d9db4829.js"><link rel="prefetch" href="/my-blog/assets/js/16.19fec63c.js"><link rel="prefetch" href="/my-blog/assets/js/17.e1318802.js"><link rel="prefetch" href="/my-blog/assets/js/18.fcf8b9e0.js"><link rel="prefetch" href="/my-blog/assets/js/19.ba8b7b9d.js"><link rel="prefetch" href="/my-blog/assets/js/4.6e387740.js"><link rel="prefetch" href="/my-blog/assets/js/5.87968e80.js"><link rel="prefetch" href="/my-blog/assets/js/6.72d314ae.js"><link rel="prefetch" href="/my-blog/assets/js/7.ac323565.js"><link rel="prefetch" href="/my-blog/assets/js/8.4a78cb7e.js"><link rel="prefetch" href="/my-blog/assets/js/9.1d3ae902.js">
    <link rel="stylesheet" href="/my-blog/assets/css/0.styles.48b128da.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/my-blog/" class="home-link router-link-active"><img src="/my-blog/assets/img/logo.png" alt="雨巷的博客" class="logo"> <span class="site-name can-hide">雨巷的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/my-blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/my-blog/iview-admin-pro/" class="nav-link">
  组件库
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/my-blog/Vue/" class="nav-link router-link-active">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/javascript/" class="nav-link">
  Javascript
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工程化" class="dropdown-title"><span class="title">工程化</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Group1
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-blog/language/chinese/" class="nav-link">
  Chinese
</a></li><li class="dropdown-subitem"><a href="/my-blog/language/japanese/" class="nav-link">
  Japanese
</a></li></ul></li><li class="dropdown-item"><h4>
          Group2
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-blog/language/chinese/" class="nav-link">
  Chinese
</a></li><li class="dropdown-subitem"><a href="/my-blog/language/japanese/" class="nav-link">
  Japanese
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="https://github.com/doctorFei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/my-blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/my-blog/iview-admin-pro/" class="nav-link">
  组件库
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/my-blog/Vue/" class="nav-link router-link-active">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/javascript/" class="nav-link">
  Javascript
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工程化" class="dropdown-title"><span class="title">工程化</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Group1
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-blog/language/chinese/" class="nav-link">
  Chinese
</a></li><li class="dropdown-subitem"><a href="/my-blog/language/japanese/" class="nav-link">
  Japanese
</a></li></ul></li><li class="dropdown-item"><h4>
          Group2
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-blog/language/chinese/" class="nav-link">
  Chinese
</a></li><li class="dropdown-subitem"><a href="/my-blog/language/japanese/" class="nav-link">
  Japanese
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="https://github.com/doctorFei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/my-blog/Vue/" aria-current="page" class="sidebar-link">Vue 中 slot 和 slot-scope 的原理</a></li><li><a href="/my-blog/Vue/vue-1.html" class="sidebar-link">Vue的响应式更新精确到组件级别</a></li><li><a href="/my-blog/Vue/vue-2.html" class="sidebar-link">Vue 中不要用 index 作为 key？</a></li><li><a href="/my-blog/Vue/vue-3.html" aria-current="page" class="active sidebar-link">Vue 的生命周期</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/my-blog/Vue/vue-3.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/my-blog/Vue/vue-3.html#初始化流程" class="sidebar-link">初始化流程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/my-blog/Vue/vue-3.html#new-vue" class="sidebar-link">new Vue</a></li><li class="sidebar-sub-header"><a href="/my-blog/Vue/vue-3.html#beforecreate-被调用完成" class="sidebar-link">beforeCreate 被调用完成</a></li><li class="sidebar-sub-header"><a href="/my-blog/Vue/vue-3.html#created-被调用完成" class="sidebar-link">created 被调用完成</a></li><li class="sidebar-sub-header"><a href="/my-blog/Vue/vue-3.html#beforemount-被调用完成" class="sidebar-link">beforeMount 被调用完成</a></li><li class="sidebar-sub-header"><a href="/my-blog/Vue/vue-3.html#mounted-被调用完成" class="sidebar-link">mounted 被调用完成</a></li></ul></li><li class="sidebar-sub-header"><a href="/my-blog/Vue/vue-3.html#更新流程" class="sidebar-link">更新流程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/my-blog/Vue/vue-3.html#beforeupdate-被调用完成" class="sidebar-link">beforeUpdate 被调用完成</a></li><li class="sidebar-sub-header"><a href="/my-blog/Vue/vue-3.html#updated-被调用完成" class="sidebar-link">updated 被调用完成</a></li></ul></li><li class="sidebar-sub-header"><a href="/my-blog/Vue/vue-3.html#销毁流程" class="sidebar-link">销毁流程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/my-blog/Vue/vue-3.html#beforedestroy-被调用完成" class="sidebar-link">beforeDestroy 被调用完成</a></li><li class="sidebar-sub-header"><a href="/my-blog/Vue/vue-3.html#destroyed-被调用完成" class="sidebar-link">destroyed 被调用完成</a></li></ul></li><li class="sidebar-sub-header"><a href="/my-blog/Vue/vue-3.html#细节" class="sidebar-link">细节</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/my-blog/Vue/vue-3.html#attrs-和-listener-的一些处理。" class="sidebar-link">$attrs 和 $listener 的一些处理。</a></li><li class="sidebar-sub-header"><a href="/my-blog/Vue/vue-3.html#子组件的初始化" class="sidebar-link">子组件的初始化</a></li><li class="sidebar-sub-header"><a href="/my-blog/Vue/vue-3.html#vnode-和-vnode-的区别" class="sidebar-link">\$vnode 和 _vnode 的区别</a></li><li class="sidebar-sub-header"><a href="/my-blog/Vue/vue-3.html#this-children-和-vnode-children" class="sidebar-link">this.\$children 和 _vnode.children</a></li></ul></li></ul></li><li><a href="/my-blog/Vue/vue-4.html" class="sidebar-link">Vue响应式原理</a></li><li><a href="/my-blog/Vue/vue-5.html" class="sidebar-link">组件通信</a></li><li><a href="/my-blog/Vue/vue-6.html" class="sidebar-link">Vue面试题（一）</a></li><li><a href="/my-blog/Vue/vue-7.html" class="sidebar-link">vue 性能优化</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue-的生命周期之间到底做了什么事清？（源码详解，带你从头梳理组件化流程）"><a href="#vue-的生命周期之间到底做了什么事清？（源码详解，带你从头梳理组件化流程）" class="header-anchor">#</a> Vue 的生命周期之间到底做了什么事清？（源码详解，带你从头梳理组件化流程）</h1> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>相信大家对 Vue 有哪些生命周期早就已经烂熟于心，但是对于这些生命周期的前后分别做了哪些事情，可能还有些不熟悉。</p> <p>本篇文章就从一个完整的流程开始，详细讲解各个生命周期之间发生了什么事情。</p> <p>注意本文不涉及 <code>keep-alive</code> 的场景和错误处理的场景。</p> <p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="vue生命周期"></p> <h2 id="初始化流程"><a href="#初始化流程" class="header-anchor">#</a> 初始化流程</h2> <h3 id="new-vue"><a href="#new-vue" class="header-anchor">#</a> new Vue</h3> <p>从 <code>new Vue(options)</code> 开始作为入口，<code>Vue</code> 只是一个简单的构造函数，内部是这样的：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Vue</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>进入了 <code>_init</code> 函数之后，先初始化了一些属性。</p> <ol><li><code>initLifecycle</code>：初始化一些属性如<code>$parent</code>，<code>$children</code>。根实例没有 <code>$parent</code>，<code>$children</code> 开始是空数组，直到它的 <code>子组件</code> 实例进入到 <code>initLifecycle</code> 时，才会往父组件的 <code>$children</code> 里把自身放进去。所以 <code>$children</code> 里的一定是组件的实例。</li> <li><code>initEvents</code>：初始化事件相关的属性，如 <code>_events</code> 等。</li> <li><code>initRender</code>：初始化渲染相关如 <code>$createElement</code>，并且定义了 <code>$attrs</code> 和 <code>$listeners</code> 为<code>浅层</code>响应式属性。具体可以查看<code>细节</code>章节。并且还定义了<code>$slots</code>、<code>$scopedSlots</code>，其中 <code>$slots</code> 是立刻赋值的，但是 <code>$scopedSlots</code> 初始化的时候是一个 <code>emptyObject</code>，直到组件的 <code>vm._render</code> 过程中才会通过 <code>normalizeScopedSlots</code> 去把真正的 <code>$scopedSlots</code> 整合后挂到 <code>vm</code> 上。</li></ol> <p>然后开始第一个生命周期：</p> <div class="language- extra-class"><pre class="language-text"><code>callHook(vm, 'beforeCreate')
</code></pre></div><h3 id="beforecreate-被调用完成"><a href="#beforecreate-被调用完成" class="header-anchor">#</a> beforeCreate 被调用完成</h3> <p><code>beforeCreate</code> 之后</p> <ol><li><p>初始化 <code>inject</code></p></li> <li><p>初始化</p></li></ol> <div class="language- extra-class"><pre class="language-text"><code>state
</code></pre></div><ul><li>初始化 <code>props</code></li> <li>初始化 <code>methods</code></li> <li>初始化 <code>data</code></li> <li>初始化 <code>computed</code></li> <li>初始化 <code>watch</code></li></ul> <ol start="3"><li>初始化 <code>provide</code></li></ol> <p>所以在 <code>data</code> 中可以使用 <code>props</code> 上的值，反过来则不行。</p> <p>然后进入 <code>created</code> 阶段：</p> <div class="language- extra-class"><pre class="language-text"><code>callHook(vm, 'created')
</code></pre></div><h3 id="created-被调用完成"><a href="#created-被调用完成" class="header-anchor">#</a> created 被调用完成</h3> <p>调用 <code>$mount</code> 方法，开始挂载组件到 <code>dom</code> 上。</p> <p>如果使用了 <code>runtime-with-compile</code> 版本，则会把你传入的 <code>template</code> 选项，或者 <code>html</code> 文本，通过一系列的编译生成 <code>render</code> 函数。</p> <ul><li>编译这个 <code>template</code>，生成 <code>ast</code> 抽象语法树。</li> <li>优化这个 <code>ast</code>，标记静态节点。（渲染过程中不会变的那些节点，优化性能）。</li> <li>根据 <code>ast</code>，生成 <code>render</code> 函数。</li></ul> <p>对应具体的代码就是：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span>template<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>optimize <span class="token operator">!==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">optimize</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果是脚手架搭建的项目的话，这一步 <code>vue-cli</code> 已经帮你做好了，所以就直接进入 <code>mountComponent</code> 函数。</p> <p>那么，确保有了 <code>render</code> 函数后，我们就可以往<code>渲染</code>的步骤继续进行了</p> <h3 id="beforemount-被调用完成"><a href="#beforemount-被调用完成" class="header-anchor">#</a> beforeMount 被调用完成</h3> <p>把 <code>渲染组件的函数</code> 定义好，具体代码是：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>拆解来看，<code>vm._render</code> 其实就是调用我们上一步拿到的 <code>render</code> 函数生成一个 <code>vnode</code>，而 <code>vm._update</code> 方法则会对这个 <code>vnode</code> 进行 <code>patch</code> 操作，帮我们把 <code>vnode</code> 通过 <code>createElm</code>函数创建新节点并且渲染到 <code>dom节点</code> 中。</p> <p>接下来就是执行这段代码了，是由 <code>响应式原理</code> 的一个核心类 <code>Watcher</code> 负责执行这个函数，为什么要它来代理执行呢？因为我们需要在这段过程中去 <code>观察</code> 这个函数读取了哪些响应式数据，将来这些响应式数据更新的时候，我们需要重新执行 <code>updateComponent</code> 函数。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span>
  <span class="token parameter">vm<span class="token operator">:</span> Component<span class="token punctuation">,</span>
  el<span class="token operator">:</span> <span class="token operator">?</span>Element<span class="token punctuation">,</span>
  hydrating<span class="token operator">?</span><span class="token operator">:</span> boolean</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Component <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> el<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>render<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>render <span class="token operator">=</span> createEmptyVNode<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">&quot;production&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">/* istanbul ignore if */</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>
        <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>template <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>template<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token string">&quot;#&quot;</span><span class="token punctuation">)</span> <span class="token operator">||</span>
        vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el <span class="token operator">||</span>
        el
      <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">warn</span><span class="token punctuation">(</span>
          <span class="token string">&quot;You are using the runtime-only build of Vue where the template &quot;</span> <span class="token operator">+</span>
            <span class="token string">&quot;compiler is not available. Either pre-compile the templates into &quot;</span> <span class="token operator">+</span>
            <span class="token string">&quot;render functions, or use the compiler-included build.&quot;</span><span class="token punctuation">,</span>
          vm
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">warn</span><span class="token punctuation">(</span>
          <span class="token string">&quot;Failed to mount component: template or render function not defined.&quot;</span><span class="token punctuation">,</span>
          vm
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">&quot;beforeMount&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> updateComponent<span class="token punctuation">;</span>
  <span class="token comment">/* istanbul ignore if */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">&quot;production&quot;</span> <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>performance <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> name <span class="token operator">=</span> vm<span class="token punctuation">.</span>_name<span class="token punctuation">;</span>
      <span class="token keyword">const</span> id <span class="token operator">=</span> vm<span class="token punctuation">.</span>_uid<span class="token punctuation">;</span>
      <span class="token keyword">const</span> startTag <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vue-perf-start:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> endTag <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vue-perf-end:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>

      <span class="token function">mark</span><span class="token punctuation">(</span>startTag<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> vnode <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">mark</span><span class="token punctuation">(</span>endTag<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">measure</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vue </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> render</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> startTag<span class="token punctuation">,</span> endTag<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token function">mark</span><span class="token punctuation">(</span>startTag<span class="token punctuation">)</span><span class="token punctuation">;</span>
      vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">mark</span><span class="token punctuation">(</span>endTag<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">measure</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vue </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> patch</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> startTag<span class="token punctuation">,</span> endTag<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// we set this to vm._watcher inside the watcher's constructor</span>
  <span class="token comment">// since the watcher's initial patch may call $forceUpdate (e.g. inside child</span>
  <span class="token comment">// component's mounted hook), which relies on vm._watcher being already defined</span>
  <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>
    vm<span class="token punctuation">,</span>
    updateComponent<span class="token punctuation">,</span>
    noop<span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_isMounted <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vm<span class="token punctuation">.</span>_isDestroyed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">&quot;beforeUpdate&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token boolean">true</span> <span class="token comment">/* isRenderWatcher */</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  hydrating <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

  <span class="token comment">// manually mounted instance, call mounted on self</span>
  <span class="token comment">// mounted is called for render-created child components in its inserted hook</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$vnode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vm<span class="token punctuation">.</span>_isMounted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">&quot;mounted&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> vm<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果是更新后调用 <code>updateComponent</code> 函数的话，<code>updateComponent</code> 内部的 <code>patch</code> 就不再是初始化时候的创建节点，而是对新旧 <code>vnode</code> 进行 <code>diff</code>，最小化的更新到 <code>dom节点</code> 上去。具体过程可以看我的上一篇文章：</p> <p><a href="https://juejin.im/post/5e8694b75188257372503722" target="_blank" rel="noopener noreferrer">为什么 Vue 中不要用 index 作为 key？（diff 算法详解）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>这一切交给 <code>Watcher</code> 完成：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>
  vm<span class="token punctuation">,</span>
  updateComponent<span class="token punctuation">,</span>
  noop<span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_isMounted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">&quot;beforeUpdate&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token boolean">true</span> <span class="token comment">/* isRenderWatcher */</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>注意这里在<code>before</code> 属性上定义了<code>beforeUpdate</code> 函数，也就是说在 <code>Watcher</code> 被响应式属性的更新触发之后，重新渲染新视图之前，会先调用 <code>beforeUpdate</code> 生命周期。</p> <p>关于 <code>Watcher</code> 和响应式的概念，如果你还不清楚的话，可以阅读我之前的文章：</p> <p><a href="https://juejin.im/post/5db6433b51882564912fc30f" target="_blank" rel="noopener noreferrer">手把手带你实现一个最精简的响应式系统来学习 Vue 的 data、computed、watch 源码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>注意，在 <code>render</code> 的过程中，如果遇到了 <code>子组件</code>，则会调用 <code>createComponent</code> 函数。</p> <p><code>createComponent</code> 函数内部，会为子组件生成一个属于自己的<code>构造函数</code>，可以理解为子组件自己的 <code>Vue</code> 函数：</p> <div class="language- extra-class"><pre class="language-text"><code>Ctor = baseCtor.extend(Ctor)
</code></pre></div><p>在普通的场景下，其实这就是 <code>Vue.extend</code> 生成的构造函数，它继承自 <code>Vue</code> 函数，拥有它的很多全局属性。</p> <p>这里插播一个知识点，除了组件有自己的<code>生命周期</code>外，其实 <code>vnode</code> 也是有自己的 <code>生命周期的</code>，只不过我们平常开发的时候是接触不到的。</p> <p>那么<code>子组件的 vnode</code> 会有自己的 <code>init</code> 周期，这个周期内部会做这样的事情：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 创建子组件</span>
<span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token function">createComponentInstanceForVnode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 挂载到 dom 上</span>
child<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>而 <code>createComponentInstanceForVnode</code> 内部又做了什么事呢？它会去调用 <code>子组件</code> 的构造函数。</p> <div class="language- extra-class"><pre class="language-text"><code>new vnode.componentOptions.Ctor(options)
</code></pre></div><p>构造函数的内部是这样的：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">Sub</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">VueComponent</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>这个 <code>_init</code> 其实就是我们文章开头的那个函数，也就是说，如果遇到 <code>子组件</code>，那么就会优先开始<code>子组件</code>的构建过程，也就是说，从 <code>beforeCreated</code> 重新开始。这是一个递归的构建过程。</p> <p>也就是说，如果我们有 <code>父 -&gt; 子 -&gt; 孙</code> 这三个组件，那么它们的初始化生命周期顺序是这样的：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>父 beforeCreate
父 create
父 beforeMount
子 beforeCreate
子 create
子 beforeMount
孙 beforeCreate
孙 create
孙 beforeMount
孙 mounted
子 mounted
父 mounted
</code></pre></div><p>然后，<code>mounted</code> 生命周期被触发。</p> <h3 id="mounted-被调用完成"><a href="#mounted-被调用完成" class="header-anchor">#</a> mounted 被调用完成</h3> <p>到此为止，组件的挂载就完成了，初始化的生命周期结束。</p> <h2 id="更新流程"><a href="#更新流程" class="header-anchor">#</a> 更新流程</h2> <p>当一个响应式属性被更新后，触发了 <code>Watcher</code> 的回调函数，也就是 <code>vm._update(vm._render())</code>，在更新之前，会先调用刚才在 <code>before</code> 属性上定义的函数，也就是</p> <div class="language- extra-class"><pre class="language-text"><code>callHook(vm, 'beforeUpdate')
</code></pre></div><p>注意，由于 Vue 的异步更新机制，<code>beforeUpdate</code> 的调用已经是在 <code>nextTick</code> 中了。 具体代码如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">nextTick</span><span class="token punctuation">(</span>flushSchedulerQueue<span class="token punctuation">)</span>

<span class="token keyword">function</span> flushSchedulerQueue <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    watcher <span class="token operator">=</span> queue<span class="token punctuation">[</span>index<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">.</span>before<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// callHook(vm, 'beforeUpdate')</span>
      watcher<span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="beforeupdate-被调用完成"><a href="#beforeupdate-被调用完成" class="header-anchor">#</a> beforeUpdate 被调用完成</h3> <p>然后经历了一系列的 <code>patch</code>、<code>diff</code> 流程后，组件重新渲染完毕，调用 <code>updated</code> 钩子。</p> <p>注意，这里是对 <code>watcher</code> 倒序 <code>updated</code> 调用的。</p> <p>也就是说，假如同一个属性通过 <code>props</code> 分别流向 <code>父 -&gt; 子 -&gt; 孙</code> 这个路径，那么收集到依赖的先后也是这个顺序，但是触发 <code>updated</code> 钩子确是 <code>孙 -&gt; 子 -&gt; 父</code> 这个顺序去触发的。</p> <div class="language- extra-class"><pre class="language-text"><code>function callUpdatedHooks (queue) {
  let i = queue.length
  while (i--) {
    const watcher = queue[i]
    const vm = watcher.vm
    if (vm._watcher === watcher &amp;&amp; vm._isMounted) {
      callHook(vm, 'updated')
    }
  }
}
</code></pre></div><h3 id="updated-被调用完成"><a href="#updated-被调用完成" class="header-anchor">#</a> updated 被调用完成</h3> <p>至此，渲染更新流程完毕。</p> <h2 id="销毁流程"><a href="#销毁流程" class="header-anchor">#</a> 销毁流程</h2> <p>在刚刚所说的更新后的 <code>patch</code> 过程中，如果发现有组件在下一轮渲染中消失了，比如 <code>v-for</code> 对应的数组中少了一个数据。那么就会调用 <code>removeVnodes</code> 进入组件的销毁流程。</p> <p><code>removeVnodes</code> 会调用 <code>vnode</code> 的 <code>destroy</code> 生命周期，而 <code>destroy</code> 内部则会调用我们相对比较熟悉的 <code>vm.$destroy()</code>。（keep-alive 包裹的子组件除外）</p> <p>这时，就会调用 <code>callHook(vm, 'beforeDestroy')</code></p> <h3 id="beforedestroy-被调用完成"><a href="#beforedestroy-被调用完成" class="header-anchor">#</a> beforeDestroy 被调用完成</h3> <p>之后就会经历一系列的<code>清理</code>逻辑，清除父子关系、<code>watcher</code> 关闭等逻辑。但是注意，<code>$destroy</code> 并不会把组件从视图上移除，如果想要手动销毁一个组件，则需要我们自己去完成这个逻辑。</p> <p>然后，调用最后的 <code>callHook(vm, 'destroyed')</code></p> <h3 id="destroyed-被调用完成"><a href="#destroyed-被调用完成" class="header-anchor">#</a> destroyed 被调用完成</h3> <h2 id="细节"><a href="#细节" class="header-anchor">#</a> 细节</h2> <h3 id="attrs-和-listener-的一些处理。"><a href="#attrs-和-listener-的一些处理。" class="header-anchor">#</a> $attrs 和 $listener 的一些处理。</h3> <p>这里额外提一下 <code>$attrs</code> 之所以只有第一层被定义为响应式，是因为一般来说深层次的响应式定义已经在父组件中定义做好了，只要保证 <code>vm.$attrs = newAttrs</code> 这样的操作能触发子组件的响应式更新即可。（在子组件的模板中使用了 <code>$attrs</code> 的情况下）</p> <p>在更新子组件 <code>updateChildComponent</code> 操作中，会去取收集到的 <code>vnode</code> 上的 <code>attrs</code> 和 <code>listeners</code> 去更新 <code>$attrs</code> 属性，这样就算子组件的模板上用了 <code>$attrs</code> 的属性也可触发响应式的更新。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> emptyObject <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;../util/index&quot;</span><span class="token punctuation">;</span>

vm<span class="token punctuation">.</span>$attrs <span class="token operator">=</span> parentVnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>attrs <span class="token operator">||</span> emptyObject<span class="token punctuation">;</span>
vm<span class="token punctuation">.</span>$listeners <span class="token operator">=</span> listeners <span class="token operator">||</span> emptyObject<span class="token punctuation">;</span>
</code></pre></div><p>有一个比较细节的操作是这样的：</p> <p>这里的 <code>emptyObject</code> 永远是同样的引用，也就能保证在没有 <code>attrs</code> 或 <code>listeners</code> 传递的时候，能够永远用同一个引用而不去触发响应式更新。</p> <p>因为 <code>defineReactive</code> 的 <code>set</code> 函数中会做这样的判断：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveSetter</span><span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> value <span class="token operator">=</span> getter <span class="token operator">?</span> <span class="token function">getter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">:</span> val<span class="token punctuation">;</span>
  <span class="token comment">// 这里引用相等 直接返回了</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>newVal <span class="token operator">===</span> value <span class="token operator">||</span> <span class="token punctuation">(</span>newVal <span class="token operator">!==</span> newVal <span class="token operator">&amp;&amp;</span> value <span class="token operator">!==</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="子组件的初始化"><a href="#子组件的初始化" class="header-anchor">#</a> 子组件的初始化</h3> <p>上文中提到，子组件的初始化也一样会走 <code>_init</code> 方法，但是和根 <code>Vue</code> 实例不同的是，在 <code>_init</code> 中会有一个分支逻辑。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>options <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>_isComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果是组件的话 走这个逻辑</span>
  <span class="token function">initInternalComponent</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>$options <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>
    <span class="token function">resolveConstructorOptions</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">,</span>
    options <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    vm
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>根级别 Vue 实例，也就是 <code>new Vue(options)</code> 生成是实例，它的 <code>$options</code> 对象大概是这种格式的，我们定义在 <code>new Vue(options)</code> 中的 <code>options</code> 对象直接合并到了 <code>$options</code> 上。</p> <div class="language- extra-class"><pre class="language-text"><code>beforeCreate: [ƒ]
beforeMount: [ƒ]
components: {test: {…}}
created: [ƒ]
data: ƒ mergedInstanceDataFn()
directives: {}
el: &quot;#app&quot;
filters: {}
methods: {change: ƒ}
mixins: [{…}]
mounted: [ƒ]
name: &quot;App&quot;
render: ƒ anonymous( )
</code></pre></div><p>而子组件实例上的 <code>$options</code> 则是这样的：</p> <div class="language- extra-class"><pre class="language-text"><code>parent: Vue {_uid: 0, _isVue: true, $options: {…}, _renderProxy: Proxy, _self: Vue, …}
propsData: {msg: &quot;hello&quot;}
render: ƒ anonymous( )
staticRenderFns: []
_componentTag: &quot;test&quot;
_parentListeners: undefined
_parentVnode: VNode {tag: &quot;vue-component-1-test&quot;, data: {…}, children: undefined, text: undefined, elm: li, …}
_propKeys: [&quot;msg&quot;]
_renderChildren: [VNode]
__proto__: Object
</code></pre></div><p>那有人会问了，为啥我在子组件里通过 <code>this.$options</code> 也能访问到定义在 <code>options</code> 里的属性啊？</p> <p>我们展开 <code>__proto__</code> 属性看一下：</p> <div class="language- extra-class"><pre class="language-text"><code>beforeCreate: [ƒ]
beforeMount: [ƒ]
created: [ƒ]
directives: {}
filters: {}
mixins: [{…}]
mounted: [ƒ]
props: {msg: {…}}
_Ctor: {0: ƒ}
_base: ƒ Vue(options)
</code></pre></div><p>原来是被挂在原型上了，具体是 <code>initInternalComponent</code> 中的这段话做的：</p> <div class="language- extra-class"><pre class="language-text"><code>const opts = vm.$options = Object.create(vm.constructor.options)
</code></pre></div><h3 id="vnode-和-vnode-的区别"><a href="#vnode-和-vnode-的区别" class="header-anchor">#</a> $vnode 和 _vnode 的区别</h3> <p>实例上有两个属性总是让人摸不着头脑，就是 <code>$vnode</code> 和 <code>_vnode</code>，</p> <p>举个例子来说，我们写了个这样的组件 <code>App</code>：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>class-app<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>test</span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><code>test</code> 组件</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>class-test<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  Hi, I'm test
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>接下来我们都以 <code>test</code> 组件举例，请仔细看清楚它们的父子关系以及使用的标签和类名。</p> <h4 id="vnode"><a href="#vnode" class="header-anchor">#</a> $vnode</h4> <p>在渲染 <code>App</code> 组件的时候，遇到了 <code>test</code> 标签，会把 <code>test</code> 组件包裹成一个 <code>vnode</code>：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>class-app<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  // 渲染到这里
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>test</span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>形如此：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>tag<span class="token operator">:</span> <span class="token string">&quot;vue-component-1-test&quot;</span>
elm<span class="token operator">:</span> li<span class="token punctuation">.</span>class<span class="token operator">-</span>test
componentInstance<span class="token operator">:</span> VueComponent <span class="token punctuation">{</span>_uid<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> _isVue<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> $options<span class="token operator">:</span> <span class="token punctuation">{</span>…<span class="token punctuation">}</span><span class="token punctuation">,</span>
componentOptions<span class="token operator">:</span> <span class="token punctuation">{</span>propsData<span class="token operator">:</span> <span class="token punctuation">{</span>…<span class="token punctuation">}</span><span class="token punctuation">,</span> listeners<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> tag<span class="token operator">:</span> <span class="token string">&quot;test&quot;</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Ctor<span class="token operator">:</span> ƒ<span class="token punctuation">}</span>
context<span class="token operator">:</span> Vue <span class="token punctuation">{</span>_uid<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> _isVue<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> $options<span class="token operator">:</span> <span class="token punctuation">{</span>…<span class="token punctuation">}</span><span class="token punctuation">,</span> _renderProxy<span class="token operator">:</span> Proxy<span class="token punctuation">,</span> _self<span class="token operator">:</span> Vue<span class="token punctuation">,</span> …<span class="token punctuation">}</span>
data<span class="token operator">:</span> <span class="token punctuation">{</span>attrs<span class="token operator">:</span> <span class="token punctuation">{</span>…<span class="token punctuation">}</span><span class="token punctuation">,</span> on<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> hook<span class="token operator">:</span> <span class="token punctuation">{</span>…<span class="token punctuation">}</span><span class="token punctuation">,</span> pendingInsert<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">}</span>
child<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>
</code></pre></div><p>这个 <code>tag</code> 为 <code>vue-component-1-test</code> 的 <code>vnode</code>，其实可以说是把整个组件给包装了起来，通过 <code>componentInstance</code> 属性可以访问到实例 <code>this</code>，</p> <p>在 <code>test</code> 组件（比如说 <code>test.vue</code> 文件）的视角来看，它应该算是 <strong>外部</strong> 的 <code>vnode</code>。（父组件在模板中读取到 <code>test.vue</code> 组件后才生成）</p> <p>它的 <code>elm</code> 属性指向组件内部的 <code>根元素</code>，也就是 <code>li.class-test</code>。</p> <p>此时，它在 <code>test</code> 组件的实例 <code>this</code> 上就保存为 <code>this.$vnode</code>。</p> <h4 id="vnode-2"><a href="#vnode-2" class="header-anchor">#</a> _vnode</h4> <p>在 <code>test</code> 组件实例上，通过 <code>this._vnode</code> 访问到的 <code>vnode</code> 形如这样：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>tag<span class="token operator">:</span> <span class="token string">&quot;li&quot;</span>
elm<span class="token operator">:</span> li<span class="token punctuation">.</span>class<span class="token operator">-</span>test
children<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>VNode<span class="token punctuation">,</span> VNode<span class="token punctuation">]</span>
context<span class="token operator">:</span> VueComponent <span class="token punctuation">{</span>_uid<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> _isVue<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> $options<span class="token operator">:</span> <span class="token punctuation">{</span>…<span class="token punctuation">}</span><span class="token punctuation">,</span> _renderProxy<span class="token operator">:</span> Proxy<span class="token punctuation">,</span> _self<span class="token operator">:</span> VueComponent<span class="token punctuation">,</span> …<span class="token punctuation">}</span>
data<span class="token operator">:</span> <span class="token punctuation">{</span>staticClass<span class="token operator">:</span> <span class="token string">&quot;class-test&quot;</span><span class="token punctuation">}</span>
parent<span class="token operator">:</span> VNode <span class="token punctuation">{</span>tag<span class="token operator">:</span> <span class="token string">&quot;vue-component-1-test&quot;</span><span class="token punctuation">,</span> data<span class="token operator">:</span> <span class="token punctuation">{</span>…<span class="token punctuation">}</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> text<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> elm<span class="token operator">:</span> li<span class="token punctuation">.</span>test<span class="token punctuation">,</span> …<span class="token punctuation">}</span>
</code></pre></div><p>可以看到，它的 <code>tag</code> 是 <code>li</code>，也就是 <code>test</code> 组件的 <code>template</code> 上声明的 <code>最外层的节点</code>，</p> <p>它的 <code>elm</code> 属性也指向组件内部的 <code>根元素</code>，也就是 <code>li.class-test</code>。</p> <p>它其实就是 <code>test</code> 组件的 <code>render</code> 函数返回的 <code>vnode</code>，</p> <p>在 <code>_update</code> 方法中也找到了来源：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_update</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token operator">:</span> VNode<span class="token punctuation">,</span> hydrating<span class="token operator">?</span><span class="token operator">:</span> boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> vm<span class="token operator">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  vm<span class="token punctuation">.</span>_vnode <span class="token operator">=</span> vnode<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>回忆一下组件是怎么初始化挂载和更新的，是不是 <code>vm._update(vm._render())</code>？</p> <p>所谓的 <code>diff</code> 算法，<code>diff</code> 的其实就是 <code>this</code> 上保存的<code>_vnode</code>，和新调用 <code>_render</code> 去生成的 <code>vnode</code> 进行 <code>patch</code>。</p> <p>而根 <code>Vue</code> 实例，也就是 <code>new Vue()</code> 的那层实例， <code>this.$vnode</code> 就是 <code>null</code>，因为并没有外层组件去渲染它。</p> <h4 id="总结关系"><a href="#总结关系" class="header-anchor">#</a> 总结关系</h4> <p><code>$vnode</code> 外层组件渲染到当前组件标签时，生成的 <code>vnode</code> 实例。</p> <p><code>_vnode</code> 是组件内部调用 <code>render</code> 函数返回的 <code>vnode</code> 实例。</p> <div class="language- extra-class"><pre class="language-text"><code>_vnode.parent === $vnode
</code></pre></div><p>他们的 <code>elm</code>，也就是实际 <code>dom元素</code>，都指向组件内部的<code>根元素</code>。</p> <h3 id="this-children-和-vnode-children"><a href="#this-children-和-vnode-children" class="header-anchor">#</a> this.$children 和 _vnode.children</h3> <p><code>$children</code> 只保存当前实例的<strong>直接子组件</strong> 实例，所以你访问不到 <code>button</code>，<code>li</code> 这些 <code>原生html标签</code>。注意是实例而不是 <code>vnode</code>，也就是通过 <code>this</code> 访问到的那玩意。</p> <p><code>_vnode.children</code>，则会把当前组件的 <code>vnode</code> 树全部保存起来，不管是<code>组件vnode</code>还是原生 html 标签生成的<code>vnode</code>，并且 原生 html 生成的 <code>vnode</code> 内部还可以通过<code>children</code>进一步访问子<code>vnode</code>。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">16 天</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/my-blog/Vue/vue-2.html" class="prev">
        Vue 中不要用 index 作为 key？
      </a></span> <span class="next"><a href="/my-blog/Vue/vue-4.html">
        Vue响应式原理
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/my-blog/assets/js/app.8b8b2b3a.js" defer></script><script src="/my-blog/assets/js/2.9a1f826b.js" defer></script><script src="/my-blog/assets/js/10.a7bc797a.js" defer></script><script src="/my-blog/assets/js/3.824b3276.js" defer></script>
  </body>
</html>
